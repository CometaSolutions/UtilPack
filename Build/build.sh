#!/bin/sh

# This script is intended to run within Docker container with .NET SDK, and actual command as parameters.
# Therefore all folder names etc are constants.

set -xe

# Build all projects
$@

# Remove UtilPack .nupkg file so if the IL stuff failes, it won't be included to artifacts
UTILPACK_DIR="/repo-dir/BuildTarget/bin/UtilPack/Release"
find "${UTILPACK_DIR}" -mindepth 1 -maxdepth 1 -type f -name "UtilPack.*.nupkg" -exec rm "{}" \;

# Build IL Generator and XML doc merger
cp /repo-dir/contents/Source/Directory.Build.BuildTargetFolders.props /repo-dir/Directory.Build.props
touch /repo-dir/BuildMarker.txt
dotnet build "/p:TargetFramework=${THIS_TFM}" /repo-dir/contents/Build/UtilPackILGenerator

# Invoke IL Generator and XML doc merger
dotnet "/repo-dir/BuildTarget/bin/UtilPackILGenerator/Release/${THIS_TFM}/UtilPackILGenerator.dll" "$UTILPACK_DIR"

# Get the dotnet directory 
DOTNET_DIR=$(dotnet --info | grep Microsoft.NETCore.App | awk '{printf substr($3, 2, length($3)-2); printf "/"; printf $2}')

# Copy il(d)asm to dotnet directory (since libcoreclr.so resides there)
IL_PACKAGES_VERSION=$(cat /repo-dir/contents/ILPackagesVersion.txt)
cp "/root/.nuget/packages/runtime.alpine.3.6-x64.microsoft.netcore.ildasm/${IL_PACKAGES_VERSION}/runtimes/alpine.3.6-x64/native/ildasm" "${DOTNET_DIR}"
cp "/root/.nuget/packages/runtime.alpine.3.6-x64.microsoft.netcore.ilasm/${IL_PACKAGES_VERSION}/runtimes/alpine.3.6-x64/native/ilasm" "${DOTNET_DIR}"

# Disassemble built UtilPack DLL into IL code
find "${UTILPACK_DIR}/" -mindepth 1 -maxdepth 1 -type d -exec "${DOTNET_DIR}/ildasm" \
  "-out={}/UtilPack.il" \
  -utf8 \
  -typelist \
  -all \
  "{}/UtilPack.dll" \;

# Assemble back the IL code from ILDASM and combine it with code generated by UtilPackILGenerator
# Don't use -key here - the ilasm on .NET Core can not sign them (most likely because of legacy C++ code hard-coded to using Windows native crypto-APIs)
find "${UTILPACK_DIR}/" -mindepth 1 -maxdepth 1 -type d -exec "${DOTNET_DIR}/ilasm" \
  -nologo \
  -dll \
  -optimize \
  "-output={}/UtilPack.dll" \
  -highentropyva \
  -quiet \
  "{}/UtilPack.il" \
  "{}/AdditionalIL.il" \;
  
# Re-sign the assemblies using own tool
dotnet build "/p:TargetFramework=${THIS_TFM}" /repo-dir/contents/Build/StrongNameSigner
find "${UTILPACK_DIR}/" -mindepth 1 -maxdepth 1 -type d -exec dotnet \
  "/repo-dir/BuildTarget/bin/StrongNameSigner/Release/${THIS_TFM}/StrongNameSigner.dll" \
  "/repo-dir/contents/Keys/UtilPack.snk" \
  "{}/UtilPack.dll" \;

# Re-package UtilPack (using dotnet build /t:Pack will cause re-build even with /p:GeneratePackageOnBuild=false /p:NoBuild=true flags, so just use dotnet pack instead)
# dotnet build /p:IsCIBuild=true /p:Configuration=Release /p:GeneratePackageOnBuild=false /p:NoBuild=true /t:Pack /v:detailed /repo-dir/contents/Source/UtilPack
dotnet pack /repo-dir/contents/Source/UtilPack -c Release --no-build /p:IsCIBuild=true
